import React, {useEffect, useState} from 'react';
import styles from './SeriesDetail.module.css';
import {
  BoldArrowLeft,
  BoldShare,
  BoldLock,
  BoldHeart,
  BoldVideo,
  BoldStar,
  LineEdit,
  LinePlus,
  LineArrowDown,
  LineDelete,
} from '@ui/Icons';
import {IconButton} from '@mui/material';
import {
  ContentEpisodeInfo,
  ContentInfo,
  ContentListInfo,
  GetContentReq,
  GetSeasonEpisodesReq,
  sendGetContent,
  sendGetSeasonEpisodes,
  sendAddSeasonNo,
  UpdateSeasonNoReq,
  sendDeleteSeasonNo,
  DeleteSeasonNoReq,
  sendDeleteEpisode,
} from '@/app/NetWork/ContentNetwork';
import {EpisodeInfo} from '@/redux-store/slices/StoryInfo';
import {Category} from '@mui/icons-material';
import {pushLocalizedRoute} from '@/utils/UrlMove';
import {useRouter} from 'next/navigation';
import {CreateContentEpisodeProps} from './CreateContentEpisode';
import SharePopup from '@/components/layout/shared/SharePopup';
import CustomPopup from '@/components/layout/shared/CustomPopup';

interface SeriesDetailProps {
  id: number;
}

export interface Seasons {
  id: number;
  name: string;
}
const SeriesDetail: React.FC<SeriesDetailProps> = ({id: contentId}) => {
  const [selectedSeason, setSelectedSeason] = useState(1);
  const [selectedTab, setSelectedTab] = useState<'Episodes' | 'About'>('Episodes');
  const [onSeasonDropdown, setSeasonDropdown] = useState(false);

  const [seasons, setSeasons] = useState<Seasons[]>([]);

  const [seriesInfo, setSeriesInfo] = useState<ContentInfo>();
  const [episodeList, setEpisodeList] = useState<ContentEpisodeInfo[]>(); // ÌÉÄÏûÖ Î≥ÄÍ≤Ω

  const [isShare, setIsShare] = useState(false);
  const [onAddSeasonPopup, setOnAddSeasonPopup] = useState(false);
  const [onDeleteEpisodePopup, setOnDeleteEpisodePopup] = useState(false);
  const [onDeleteEpisodeNum, setOnDeleteEpisodeNum] = useState(0);
  useEffect(() => {}, [episodeList]);
  const handleShare = async () => {
    const shareData = {
      title: 'Í≥µÏú†ÌïòÍ∏∞ Ï†úÎ™©',
      text: 'Ïù¥ ÎßÅÌÅ¨Î•º ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî!',
      url: window.location.href, // ÌòÑÏû¨ ÌéòÏù¥ÏßÄ URL
    };

    if (navigator.share) {
      try {
        await navigator.share(shareData); // ÎÑ§Ïù¥Ìã∞Î∏å Í≥µÏú† UI Ìò∏Ï∂ú
      } catch (error) {
        console.error('Í≥µÏú† Ïã§Ìå®:', error);
      }
    } else {
      setIsShare(true);
    }
  };

  const router = useRouter();
  const navigateToCreateContentEpisode = ({
    contentId,
    curSeason,
    curEpisodeCount,
    episodeId,
  }: CreateContentEpisodeProps) => {
    // id Î∞∞Ïó¥ ÏÉùÏÑ± (contentIdÍ∞Ä ÏûàÏùÑ Í≤ΩÏö∞ Ìè¨Ìï®)
    console.log('episodeId', episodeId);
    const ids = contentId
      ? [contentId, curSeason, curEpisodeCount, episodeId]
      : [curSeason, curEpisodeCount, episodeId];

    // Í∏∞Ï°¥Ïùò pushLocalizedRoute Ìï®ÏàòÎ•º ÌôúÏö©ÌïòÏó¨ ÎùºÏö∞ÌåÖ ÏàòÌñâ
    if (!episodeId) pushLocalizedRoute(`/create/content/episode/series/${ids.join('/')}`, router);
    else pushLocalizedRoute(`/update/content/series/episode/${ids.join('/')}`, router);
  };

  const deleteEpisode = async (contentEpisodeId: number) => {
    try {
      const response = await sendDeleteEpisode({contentEpisodeId});

      if (response.resultCode === 0) {
        console.log('‚úÖ ÏóêÌîºÏÜåÎìú ÏÇ≠Ï†ú ÏôÑÎ£å');

        fetchSeasonEpisodes(selectedSeason);
      } else {
        console.error('‚ùå ÏóêÌîºÏÜåÎìú ÏÇ≠Ï†ú Ïã§Ìå®:', response.resultMessage);
      }
    } catch (error) {
      console.error('üö® API Ìò∏Ï∂ú Ï§ë Ïò§Î•ò Î∞úÏÉù:', error);
    }
  };

  const addSeason = async () => {
    if (!seriesInfo) return;
    const newSeasonNo = (seriesInfo.maxSeasonNo || 0) + 1; // ÌòÑÏû¨ maxSeasonNo + 1
    const payload: UpdateSeasonNoReq = {
      contentId: seriesInfo.id!,
      seasonNo: newSeasonNo,
    };

    try {
      const response = await sendAddSeasonNo(payload);
      if (response.data) {
        console.log(`ÏãúÏ¶å ${newSeasonNo} Ï∂îÍ∞ÄÎê®`);

        // maxSeasonNo Ï¶ùÍ∞Ä
        setSeriesInfo(prev => (prev ? {...prev, maxSeasonNo: newSeasonNo} : prev));

        // ÏãúÏ¶å Î¶¨Ïä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        setSeasons(prevSeasons => [...prevSeasons, {id: newSeasonNo, name: `Season ${newSeasonNo}`}]);
        fetchSeasonEpisodes(selectedSeason);
      }
    } catch (error) {
      console.error('ÏãúÏ¶å Ï∂îÍ∞Ä Ïã§Ìå®:', error);
    }
  };

  // üìå ÏãúÏ¶å ÏÇ≠Ï†ú (ÏÑúÎ≤Ñ ÏöîÏ≤≠)
  const removeSeason = async (seasonNo: number) => {
    if (!seriesInfo) return;

    console.log(seasonNo);
    const payload: DeleteSeasonNoReq = {
      contentId: seriesInfo.id!,
      deleteSeasonNo: seasonNo,
    };

    try {
      const response = await sendDeleteSeasonNo(payload);

      if (response.data && response.data.lastSeasonNo !== undefined) {
        console.log(`ÏãúÏ¶å ${seasonNo} ÏÇ≠Ï†úÎê®, ÎßàÏßÄÎßâ ÏãúÏ¶å Î≤àÌò∏: ${response.data.lastSeasonNo}`);

        // maxSeasonNo ÏóÖÎç∞Ïù¥Ìä∏
        setSeriesInfo(prev => prev && {...prev, maxSeasonNo: response.data!.lastSeasonNo});

        // ÏãúÏ¶å Î¶¨Ïä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ (ÏûêÎèôÏúºÎ°ú Î≤àÌò∏ Ïû¨Ï†ïÎ†¨)
        setSeasons(
          prevSeasons =>
            prevSeasons
              .filter(season => season.id !== seasonNo) // ÏÇ≠Ï†úÎêú ÏãúÏ¶å Ï†úÍ±∞
              .map((season, index) => ({id: index + 1, name: `Season ${index + 1}`})), // ID Ïû¨Ï†ïÎ†¨
        );

        fetchSeasonEpisodes(selectedSeason);
      } else {
        console.warn('ÏÑúÎ≤Ñ ÏùëÎãµÏóê lastSeasonNoÍ∞Ä ÏóÜÏäµÎãàÎã§.');
      }
    } catch (error) {
      console.error('ÏãúÏ¶å ÏÇ≠Ï†ú Ïã§Ìå®:', error);
      alert('ÏãúÏ¶å ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
    }
  };

  useEffect(() => {
    if (seriesInfo?.maxSeasonNo) {
      const generatedSeasons = Array.from({length: seriesInfo.maxSeasonNo}, (_, i) => ({
        id: i + 1,
        name: `Season ${i + 1}`,
      }));
      setSeasons(generatedSeasons);
    }
  }, [seriesInfo?.maxSeasonNo]);

  useEffect(() => {
    fetchSeasonEpisodes(selectedSeason);
  }, [selectedSeason]);

  const fetchSeasonEpisodes = async (index: number) => {
    if (!seriesInfo) return;

    const payload: GetSeasonEpisodesReq = {
      contentId: seriesInfo.id ? seriesInfo.id : 0,
      seasonNo: index,
    };

    try {
      const response = await sendGetSeasonEpisodes(payload);

      if (response.data?.episodeList) {
        const transformedEpisodes: ContentEpisodeInfo[] = response.data.episodeList.map(episode => ({
          id: episode.episodeId,
          userId: 0, // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï (ÌïÑÏöî Ïãú APIÏóêÏÑú Ï†úÍ≥µÌïòÎäî Í∞íÏúºÎ°ú Î≥ÄÍ≤Ω)
          contentId: seriesInfo.id || 0,
          seasonNo: index,
          episodeNo: episode.episodeNo,
          thumbnailUrl: episode.thumbnailUrl,
          name: episode.episodeName,
          description: '',
          categoryType: 0,
          nsfw: false,
          monetization: false,
          salesStarEa: 0,
          likeCount: 0,
          episodeVideoInfo: undefined,
          episodeWebtoonInfo: undefined,
        }));

        setEpisodeList(transformedEpisodes);
        console.log('ÏóêÌîºÏÜåÎìú Î™©Î°ù:', transformedEpisodes);
      }
    } catch (error) {
      console.error('ÏóêÌîºÏÜåÎìú Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®:', error);
    }
  };

  useEffect(() => {
    const fetchContent = async (contentId: number) => {
      const payload: GetContentReq = {contentId};

      try {
        const response = await sendGetContent(payload);
        if (response.data) {
          console.log('ÏΩòÌÖêÏ∏† Ï†ïÎ≥¥:', response.data.contentInfo);
          setSeriesInfo(response.data.contentInfo);
          fetchSeasonEpisodes(1);
        }
      } catch (error) {
        console.error('ÏΩòÌÖêÏ∏† Ï°∞Ìöå Ïã§Ìå®:', error);
      }
    };

    fetchContent(contentId);
  }, []);

  useEffect(() => {
    fetchSeasonEpisodes(selectedSeason);
  }, [seriesInfo]);

  return (
    <div className={styles.container}>
      {/* ÏÉÅÎã® Î∞∞Í≤Ω Î∞è ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò */}
      <div className={styles.header} style={{backgroundImage: `url(${seriesInfo?.thumbnailUrl})`}}>
        <div className={styles.topNav}>
          <button
            className={styles.iconButton}
            onClick={() => {
              pushLocalizedRoute(`/create/content`, router);
            }}
          >
            <img src={BoldArrowLeft.src} alt="Back" />
          </button>
          {/* <button className={styles.iconButton}>
            <img src={LineEdit.src} alt="Edit" />
          </button> */}
        </div>
      </div>

      <div className={styles.contentContainer}>
        {/* Ïû•Î•¥ Î∞è Í≥µÏú† Î≤ÑÌäº */}
        <div className={styles.genreShare}>
          <span className={styles.genres}>{seriesInfo?.genre}</span>
          <button className={styles.iconButton} onClick={() => handleShare()}>
            <img src={BoldShare.src} alt="Share" />
          </button>
        </div>

        {/* ÌÉ≠ Î©îÎâ¥ */}
        <div className={styles.tabs}>
          <div className={styles.tabContainer}>
            <button
              className={`${styles.tabButton} ${selectedTab === 'Episodes' ? styles.activeTab : ''}`}
              onClick={() => setSelectedTab('Episodes')}
            >
              Episodes
            </button>
            <button
              className={`${styles.tabButton} ${selectedTab === 'About' ? styles.activeTab : ''}`}
              onClick={() => setSelectedTab('About')}
            >
              About
            </button>
            {/* Ïù¥ÎèôÌïòÎäî Î∞ëÏ§Ñ */}
            <div className={styles.tabUnderline} style={{left: selectedTab === 'Episodes' ? '0px' : '80px'}} />
          </div>
        </div>

        {/* ÏãúÏ¶å ÏÑ†ÌÉù Î∞è Ï∂îÍ∞Ä Î≤ÑÌäº */}
        <div className={styles.controls}>
          <button className={`${styles.seasonDropdown} ${onSeasonDropdown === true ? styles.onSeasonDropdown : ''}`}>
            <div>Season {selectedSeason}</div>
            <img
              src={LineArrowDown.src}
              className={`${styles.lineArrowDown} ${onSeasonDropdown === true ? styles.onLineArrowDown : ''}`}
              onClick={() => setSeasonDropdown(!onSeasonDropdown)}
            />
          </button>
          {onSeasonDropdown && (
            <>
              <div className={styles.seasonDropdownContainer}>
                <div
                  className={styles.seasonDropdownAddButton}
                  onClick={() => {
                    setOnAddSeasonPopup(true);
                  }}
                >
                  + Add Season
                </div>
                <div className={styles.seasonDropdownBox}>
                  {seasons.map(season => (
                    <div
                      key={season.id}
                      className={styles.seasonDropdownEpisodeItem}
                      onClick={() => {
                        setSelectedSeason(season.id);
                        setSeasonDropdown(false);
                      }}
                    >
                      <span style={{color: 'black'}}>{season.name}</span>
                      <button onClick={() => removeSeason(season.id)}>
                        {seasons.length > 1 && <img src={LineDelete.src} className={styles.blackFilter}></img>}
                      </button>
                    </div>
                  ))}
                </div>
              </div>
            </>
          )}
        </div>
        {/* ÏÉàÎ°úÏö¥ ÏóêÌîºÏÜåÎìú Ï∂îÍ∞Ä Î≤ÑÌäº */}
        <button
          className={styles.addEpisode}
          onClick={() => {
            navigateToCreateContentEpisode({
              contentId: contentId,
              curSeason: selectedSeason,
              curEpisodeCount: episodeList ? episodeList.length : 0,
            });
          }}
        >
          + New Episode
        </button>

        {/* ÏóêÌîºÏÜåÎìú Î¶¨Ïä§Ìä∏ */}
        <div className={styles.episodeList}>
          {episodeList &&
            episodeList.map((ep, index) => (
              <div key={ep.id} className={styles.episodeItem}>
                <div className={styles.episodeThumbnail} style={{backgroundImage: `url(${ep.thumbnailUrl})`}}></div>
                <div className={styles.episodeInfo}>
                  <div className={styles.epTitleText}>
                    {index + 1}. {ep.name}
                  </div>
                  {seriesInfo?.categoryType == 1 && (
                    <div className={styles.epDuration}>{ep.episodeVideoInfo?.videoSourcePlayTime}</div>
                  )}
                </div>
                <div className={styles.episodeActions}>
                  <div style={{display: 'flex', gap: '10px'}}>
                    <button
                      className={styles.iconButton}
                      onClick={() => {
                        if (ep.id) {
                          setOnDeleteEpisodeNum(ep.id);
                          setOnDeleteEpisodePopup(true);
                        }
                      }}
                    >
                      <img src={LineDelete.src} alt="Delete" className={styles.editIcon} />
                    </button>
                    <button
                      className={styles.iconButton}
                      onClick={() => {
                        navigateToCreateContentEpisode({
                          contentId: contentId,
                          curSeason: selectedSeason,
                          curEpisodeCount: episodeList ? episodeList.length : 0,
                          episodeId: ep.id,
                        });
                      }}
                    >
                      <img src={LineEdit.src} alt="Edit" className={styles.editIcon} />
                    </button>
                  </div>
                  <div className={styles.rating}>
                    <img src={BoldStar.src} className={styles.starIcon} />
                    <span className={styles.rateText}>{ep.likeCount}</span>
                  </div>
                </div>
              </div>
            ))}
        </div>
      </div>
      <SharePopup
        open={isShare}
        title={'Share'}
        url={window.location.href}
        onClose={() => setIsShare(false)}
      ></SharePopup>
      {onAddSeasonPopup && (
        <CustomPopup
          type="alert"
          title={`Would you like to add a new Season ${(seriesInfo?.maxSeasonNo || 0) + 1}?"`}
          description=""
          buttons={[
            {
              label: 'No',
              onClick: () => setOnAddSeasonPopup(false),
              isPrimary: false,
            },
            {
              label: 'Yes',
              onClick: () => {
                addSeason();
                setOnAddSeasonPopup(false);
              },
              isPrimary: true,
            },
          ]}
        />
      )}
      {onDeleteEpisodePopup && (
        <CustomPopup
          type="alert"
          title="Are you sure you want to delete this series?"
          description="All episodes within the series will also be deleted and cannot be recovered."
          buttons={[
            {
              label: 'Cancel',
              onClick: () => setOnDeleteEpisodePopup(false),
              isPrimary: false,
            },
            {
              label: 'Confirm',
              onClick: () => {
                deleteEpisode(onDeleteEpisodeNum);
                setOnDeleteEpisodePopup(false);
              },
              isPrimary: true,
            },
          ]}
        />
      )}
    </div>
  );
};

export default SeriesDetail;
